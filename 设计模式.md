用户参与一个活动，然后完成一系列的任务，最后可以得到一些奖励作为回报。活动的奖励包含外卖、酒旅和美食等多种品类券，现在需要你帮忙设计一套奖励发放方案
```java
// 奖励服务
class RewardService {
    // 使用对入参的条件判断进行发奖
    public void issueReward(String rewardType, Object ... params) {
        if ("Waimai".equals(rewardType)) {
            // do something
        } else if ("Hotel".equals(rewardType)) {
            // do something
        } else if ("Food".equals(rewardType)) {
            // do something
        } else {
          	throw new IllegalArgumentException("rewardType error!");
        }
    }
}
```

- 不符合开闭原则。如果后续新增品类券的话，需要直接修改主干代码。而我们提倡代码对修改封闭。
- 不符合迪米特法则。发奖逻辑和各个下游接口高度耦合，这导致接口的改变将直接影响到代码的组织，使得代码的可维护性降低。

#### 策略模式

>策略模式：定义一系列的算法，并将每一个算法封装起来，使它们可以相互替换
>
>- 环境（Context）：持有一个策略类的引用，最终给客户端调用。
>- 抽象策略（Strategy）：定义了一个公共接口，各种不同的算法以不同的方式实现这个接口。环境通过这个接口调用不同的算法，一般使用接口或抽象类实现。
>- 具体策略（Concrete Strategy）：实现了抽象策略定义的接口，提供具体的算法实现。

#### 适配器模式

>适配器模式：将一个类的接口转换成用户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类能一起工作的类能一起工作。
>
>- 适配者（Adaptee）：被访问和适配的现存组件库中的组件接口
>- 适配器（Adapter）：转换器，通过继承或引用适配者的对象，把适配者转换成目标接口，让用户按目标接口的格式访问适配者
>- 目标（Target）：用户所期望的接口，可以是抽象类或接口

```java
// 优化后的服务
class RewardService {
    public void issueReward(String rewardType, Object ... params) {
        Strategy strategy = StrategyContext.getStrategy(rewardType);
        strategy.issue(params);
    }
}

// 环境：使用分支判断获取的策略上下文
// 目标
class StrategyContext {
    public static Strategy getStrategy(String rewardType) {
        switch (rewardType) {
            case "Waimai":
                return new Waimai();
            case "Hotel":
                return new Hotel();
            case "Food":
                return new Food();
            default:
                throw new IllegalArgumentException("rewardType error!");
        }
    }
}
```



```java
// 抽象策略
// 适配者：并通过适配器的思想将各个下游接口类适配成策略类
interface Strategy {
    void issue(Object ... params);
}
// 外卖策略
// 外卖适配者
class Waimai implements Strategy {
    @Override
    public void issue(Object... params) {
        // do something
    }
}
// 酒旅策略
class Hotel implements Strategy {
    @Override
    public void issue(Object... params) {
        // do something
    }
}
// 美食策略
class Food implements Strategy {
    @Override
    public void issue(Object... params) {
        // do something
    }
```

- 策略类是无状态的模型。
  - 可以做成单例的以减少开销
- 环境类的获取策略方法职责很明确，但是依然没有完全做的对修改封闭。
  - 使用一个注册表来记录各个策略类的注册信息，并提供接口供策略类调用进行注册

#### 单例模式

>单例模式属于创建型模式，它提供了一种创建对象的最佳方式。
>
>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

在策略环境类中使用一个注册表来记录各个策略类的注册信息，并提供接口供策略类调用进行注册。同时使用**饿汉式单例模式**去优化策略类的设计：

```java
class RewardService {
    public void issueReward(String rewardType, Object ... params) {
        Strategy strategy = StrategyContext.getStrategy(rewardType);
        strategy.issue(params);
    }
}

// 策略上下文，用于管理策略的注册和获取
class StrategyContext {
    // 注册表：记录各个策略类的注册信息
    private static final Map<String, Strategy> registerMap = new HashMap<>();
    // 策略注册
    public static void registerStrategy(String rewardType, Strategy strategy) {
        registerMap.putIfAbsent(rewardType, strategy);
    }
    // 策略获取
    public static Strategy getStrategy(String rewardType) {
        return registerMap.get(rewardType);
    }
}
// 抽象策略类
abstract class AbstractStrategy implements Strategy {
    // 类注册方法
    public void register() {
        StrategyContext.registerStrategy(getClass().getSimpleName(), this);
    }
}
// 单例外卖策略
class Waimai extends AbstractStrategy implements Strategy {
    private static final Waimai instance = new Waimai();
    private Waimai() {
        register();
    }
    public static Waimai getInstance() {
        return instance;
    }
    @Override
    public void issue(Object... params) {
        // do something
    }
}
// 单例酒旅策略
class Hotel extends AbstractStrategy implements Strategy {
  	private static final Hotel instance = new Hotel();
    private Hotel() {
        register();
    }
    public static Hotel getInstance() {
        return instance;
    }
    @Override
    public void issue(Object... params) {
        // do something
    }
}
// 单例美食策略
class Food extends AbstractStrategy implements Strategy {
  	private static final Food instance = new Food();
    private Food() {
        register();
    }
    public static Food getInstance() {
        return instance;
    }
    @Override
    public void issue(Object... params) {
        // do something
    }
}
```

### 任务模型的设计

```JAVA
// 任务状态枚举
@AllArgsConstructor
@Getter
enum TaskState {
    INIT("初始化"),
    ONGOING( "进行中"),
    PAUSED("暂停中"),
    FINISHED("已完成"),
    EXPIRED("已过期")
    ;
    private final String message;
}

// 行为枚举
@AllArgsConstructor
@Getter
enum ActionType {
    START(1, "开始"),
    STOP(2, "暂停"),
    ACHIEVE(3, "完成"),
    EXPIRE(4, "过期")
    ;
    private final int code;
    private final String message;
}
```



```java
class Task {
    private Long taskId;
    // 任务的默认状态为初始化
    private TaskState state = TaskState.INIT;
    // 活动服务
    private ActivityService activityService;
    // 任务管理器
    private TaskManager taskManager;
    // 使用条件分支进行任务更新
    public void updateState(ActionType actionType) {
        if (state == TaskState.INIT) {
            if (actionType == ActionType.START) {
                state = TaskState.ONGOING;
            }
        } else if (state == TaskState.ONGOING) {
            if (actionType == ActionType.ACHIEVE) {
                state = TaskState.FINISHED;
                // 任务完成后进对外部服务进行通知
                activityService.notifyFinished(taskId);
                taskManager.release(taskId);
            } else if (actionType == ActionType.STOP) {
                state = TaskState.PAUSED;
            } else if (actionType == ActionType.EXPIRE) {
                state = TaskState.EXPIRED;
            }
        } else if (state == TaskState.PAUSED) {
            if (actionType == ActionType.START) {
                state = TaskState.ONGOING;
            } else if (actionType == ActionType.EXPIRE) {
                state = TaskState.EXPIRED;
            }
        }
    }
}
```

#### 状态模式

```java
// 任务状态抽象接口
interface State {
    // 默认实现，不做任何处理
    default void update(Task task, ActionType actionType) {
        // do nothing
    }
}
// 任务初始状态
class TaskInit implements State {
    @Override
    public void update(Task task, ActionType actionType) {
        if  (actionType == ActionType.START) {
            task.setState(new TaskOngoing());
        }
    }
}
// 任务进行状态
class TaskOngoing implements State {
    private ActivityService activityService;
    private TaskManager taskManager; 
    @Override
    public void update(Task task, ActionType actionType) {
        if (actionType == ActionType.ACHIEVE) {
            task.setState(new TaskFinished());
            // 通知
            activityService.notifyFinished(taskId);
            taskManager.release(taskId);
        } else if (actionType == ActionType.STOP) {
            task.setState(new TaskPaused());
        } else if (actionType == ActionType.EXPIRE) {
            task.setState(new TaskExpired());
        }
    }
}
// 任务暂停状态
class TaskPaused implements State {
    @Override
    public void update(Task task, ActionType actionType) {
        if (actionType == ActionType.START) {
            task.setState(new TaskOngoing());
        } else if (actionType == ActionType.EXPIRE) {
            task.setState(new TaskExpired());
        }
    }
}
// 任务完成状态
class TaskFinished implements State {

}
// 任务过期状态
class TaskExpired implements State {

}
@Data
class Task {
    private Long taskId;
    // 初始化为初始态
    private State state = new TaskInit();
    // 更新状态
    public void updateState(ActionType actionType) {
        state.update(this, actionType);
    }
}
```



#### 有状态

https://cloud.tencent.com/developer/article/1620559

https://www.cnblogs.com/xubiao/p/6567349.html

有数据存储的功能。有状态对象（Stateful Bean），就是实例对象，可以保持数据，是非线程安全的。在不同方法调用期间不保留任何状态。

#### 无状态

不能保持数据，无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。

#### Context

通俗的理解，上下文，也就是执行任务所需要的相关信息。这个任务可以是一段代码，一个线程，一个进程，一个函数。当这个“任务”，相关信息需要保存下来，就可以使用Context来记录。
