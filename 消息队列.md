## 简介



## AMQP

AMQP协议详解：https://zhuanlan.zhihu.com/p/147675691

![AMQP](C:\Users\yuki\Desktop\AMQP.png)



## RabbitMQ安装

### windows

https://www.cnblogs.com/yangh965/p/5862347.html

erlang：https://erlang.org/download/otp_win64_24.3.exe

RabbitMQ 3.9.14 ：

https://objects.githubusercontent.com/github-production-release-asset-2e65be/924551/08ad33aa-f5c8-4582-a0ce-e5a9f9732943?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=AKIAIWNJYAX4CSVEH53A%2F20220411%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20220411T053659Z&X-Amz-Expires=300&X-Amz-Signature=33c2c07d90ad6c2bc2e51a27169861ba65c68d3b148008c5bf2006d61b72c76c&X-Amz-SignedHeaders=host&actor_id=0&key_id=0&repo_id=924551&response-content-disposition=attachment%3B%20filename%3Drabbitmq-server-3.9.14.exe&response-content-type=application%2Foctet-str

### Docker



## Spring  Cloud  Stream

解耦消息中间件。门面模式（外观模式），类似于日志门面SLF4J。依赖于门面，而不是具体的实现

in和out的主体是 “者”，in 我就是消费者， out 我就是生产者

#### 1. 配置环境

```yml
spring:
  cloud:
    stream:
      binders:  # 绑定器就是封装了目标中间件的包（可以配置多个，一个绑定器就是一个消息中间件）
        defaultRabbit:  # 绑定器名称（自定义）
          type: rabbit  # 使用的消息中间件类型（这里用的是RabbitMQ）
          environment:	#配置rabbitmq连接环境
            spring:
              rabbitmq:
                host: 192.168.0.118
                port: 5672
                username: yuki
                password: yukicomic
                virtual-host: /
      bindings:
        robot_comment_out_delay:	# output表示消息生产通道
          destination: delay-robot-comment	#绑定RabbitMQ的exchange名称，交换模式默认是topic
          content-type: application/json
          group: delay	#把功能相同的服务实例的 group 设置为同一个，那么就会只有一个实例来消费消息，避免重复消费的情况。同时，group名称也会成为 queue 的名称
        robot_comment_in_delay:		# input表示消息消费通道
          destination: delay-robot-comment
          content-type: application/json
          group: delay

      rabbit:
        bindings:
          #延迟队列
          robot_comment_out_delay:
            producer:
              delayed-exchange: true
          robot_comment_in_delay:
            consumer:
              delayed-exchange: true
```

```java
// 如果只做生产者就不要指定input，否则应用就会认为这个生产者服务也会消费消息，消息会被发送到这个服务
// 如果没有在此服务中订阅消息（@StreamListener），当消息被发送到这个服务时，就会出现如下异常
org.springframework.messaging.MessageDeliveryException: Dispatcher has no subscribers for channel
```



#### 2. 定义消息通道Channel（消息的来源和去向）

简单的可以放在同一个接口中定义。也可以拆分成两个接口：一个Source、一个Sink

```java
@Component
public interface DelayMqMessage {
    /**
     * 延时队列消费者
     */
    String ROBOT_COMMENT_IN_DELAY = "robot_comment_in_delay";
    /**
     * 延时队列生产者
     */
    String ROBOT_COMMENT_OUT_DELAY = "robot_comment_out_delay";
    
    /**
     * 消费者
     */
    @Input(ROBOT_COMMENT_IN_DELAY)
    SubscribableChannel delayRobotCommentInput();

    /**
     * 生产者
     */
    @Output(ROBOT_COMMENT_OUT_DELAY)
    MessageChannel delayRobotCommentOutput();
}
```

#### 3. 实现生产者方法

```java
@Slf4j
@Component
public class RabbitUtils {
    
    @Autowired
    private static DelayMqMessage delayMqMessage;

    /**
     * 马甲发送延时队列
     */
    // 也可以用  @SendTo(DelayMqMessage.ROBOT_COMMENT_IN_DELAY)
    public static void sendDelayRobotComment(String msg,Long delay){
        delayMqMessage.delayRobotCommentOutput()
                .send(MessageBuilder.withPayload(msg)
                        .setHeader("x-delay",delay).build());
    }
}
```

#### 4.实现消费者方法

```java
@Slf4j
@Component
// 启动stream，并指定channel
@EnableBinding(DelayMqMessage.class)
@RequiredArgsConstructor
public class DelayMessageReceiver {

    private final CiyoCommentService commentService;

    // @SendTo(DelayMqMessage.ROBOT_COMMENT_IN_DELAY) 消费的同时也可以生产消息
    @StreamListener(DelayMqMessage.ROBOT_COMMENT_IN_DELAY)
    public void receiveRobotComment(String msg) {
        log.info("---------接受到消息: {}", msg);
        // 执行定时任务
        CommentMessageDTO messageDTO = JSONUtil.toBean(msg, CommentMessageDTO.class);
        commentService.sendRobotComment(messageDTO);
    }
}
```



## 定时任务

https://zhuanlan.zhihu.com/p/383702823

https://juejin.cn/post/7038892531706232845

Rabbitmq本身是没有延迟队列的。想要Rabbitmq实现延迟队列，需要使用Rabbitmq的死信交换机（Exchange）和消息的存活时间TTL（Time To Live）。

简单说：

1. 用户创建定时任务
2. 创建一个消息，TTL为延时触发时间，发送到正常的消息队列（没有消费者）
3. TTL到时间，此消息过期，进入死信交换机
4. 死信交换机将消息投递到消息队列
5. 消费者进行消费，执行任务

#### 死信交换机

死信交换机就是普通的交换机，只是因为我们把过期的消息扔进去，所以叫死信交换机，并不是说死信交换机是某种特定的交换机。

一个消息在满足如下条件下，会进死信交换机，记住这里是交换机而不是队列，一个交换机可以对应很多队列。

1. 一个消息被Consumer拒收了，并且reject方法的参数里requeue是false。也就是说不会被再次放在队列里，被其他消费者使用。
2. 消息的TTL到了，消息过期了。
3. 队列的长度限制满了。排在前面的消息会被丢弃或者扔到死信路由上。

#### 消息存活时间

RabbitMQ可以对队列和消息分别设置TTL。

- 对队列设置就是队列没有消费者连着的保留时间，

- 也可以对每一个单独的消息做单独的设置。超过了这个时间，我们认为这个消息就死了，称之为死信。

如果队列设置了，消息也设置了，那么会取小的。所以一个消息如果被路由到不同的队列中，这个消息死亡的时间有可能不一样（不同的队列设置）。

可以通过设置消息的expiration字段或者x-message-ttl属性来设置时间，两者是一样的效果。

- 设置消息的expiration字段
- 或者设置信息的x-message-ttl属性

## 事务

https://www.cnblogs.com/chjxbt/p/11412727.html

**事务消息需要消息队列提供相应的功能才能实现，kafka和RocketMQ都提供了事务相关功能。**

![事务消息](C:\Users\yuki\Desktop\pic\事务消息.jpg)

对于订单系统：

- 首先，订单系统在消息队列上开启一个事务。
- 然后订单系统给消息服务器发送一个“半消息”，这个半消息不是说消息内容不完整，它包含的内容就是完整的消息内容，半消息和普通消息的唯一区别是，在事务提交之前，对于消费者来说，这个消息是不可见的。
- 半消息发送成功后，订单系统就可以执行本地事务了，在订单库中创建一条订单记录，并提交订单库的数据库事务。
- 然后根据本地事务的执行结果决定提交或者回滚事务消息。如果订单创建成功，那就提交事务消息，购物车系统就可以消费到这条消息继续后续的流程。如果订单创建失败，那就回滚事务消息，购物车系统就不会收到这条消息。这样就基本实现了“要么都成功，要么都失败”的一致性要求。

对于购物车系统：

- 对于购物车系统收到订单创建成功消息清理购物车这个操作来说，失败的处理比较简单，**只要成功执行购物车清理后再提交消费确认即可**，如果失败，**由于没有提交消费确认，消息队列会自动重试**。

 

**如果在第四步提交事务消息时失败了怎么办？Kafka 和 RocketMQ 给出了 2 种不同的解决方案：**

1、Kafka 的解决方案：

直接抛出异常，让用户自行处理。我们可以在业务代码中反复重试提交，直到提交成功，或者删除之前创建的订单进行补偿。

2、RocketMQ 的解决方案：

在 RocketMQ 中的事务实现中，增加了**事务反查的机制**来解决事务消息提交失败的问题。如果 Producer 也就是订单系统，在提交或者回滚事务消息时发生网络异常，RocketMQ 的 Broker 没有收到提交或者回滚的请求，Broker 会定期去 Producer 上**反查这个事务对应的本地事务的状态**，然后根据反查结果决定提交或者回滚这个事务。为了支撑这个事务反查机制，我们的业务代码需要**实现一个反查本地事务状态的接口**，告知 RocketMQ 本地事务是成功还是失败。

![MQ事务](C:\Users\yuki\Desktop\pic\MQ事务.jpg)

## 参考

https://developer.aliyun.com/article/769883#slide-9

https://www.cnblogs.com/fengzheng/p/11576661.html

https://blog.csdn.net/jiangsir_sub/article/details/97522674

https://www.cnblogs.com/chjxbt/p/11412727.html

